<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>Talking to Servers: LFE &amp; Clojure</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Clojang</span> <span class="project-version">0.1.0-dev</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="05-building-jinterface.html"><div class="inner"><span>Building JInterface for Clojure</span></div></a></li><li class="depth-1 "><a href="10-low-level-api.html"><div class="inner"><span>Clojang User&apos;s Guide: The Low-level API</span></div></a></li><li class="depth-1 "><a href="20-mid-level-api.html"><div class="inner"><span>Clojang User&apos;s Guide: The Mid-level API</span></div></a></li><li class="depth-1  current"><a href="30-talking-to-servers.html"><div class="inner"><span>Talking to Servers: LFE &amp; Clojure</span></div></a></li><li class="depth-1 "><a href="40-creating-apps.html"><div class="inner"><span>Apps Tutorial</span></div></a></li><li class="depth-1 "><a href="98-other-resources.html"><div class="inner"><span>Other Resources</span></div></a></li><li class="depth-1 "><a href="99-other-versions.html"><div class="inner"><span>API Docs (All Versions)</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>clojang</span></div></div></li><li class="depth-2 branch"><a href="clojang.conn.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>conn</span></div></a></li><li class="depth-2 branch"><a href="clojang.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="clojang.dev.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>dev</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>jinterface</span></div></div></li><li class="depth-3"><a href="clojang.jinterface.erlang.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>erlang</span></div></a></li><li class="depth-4 branch"><a href="clojang.jinterface.erlang.atom.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>atom</span></div></a></li><li class="depth-4 branch"><a href="clojang.jinterface.erlang.boolean.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>boolean</span></div></a></li><li class="depth-4 branch"><a href="clojang.jinterface.erlang.char.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>char</span></div></a></li><li class="depth-4 branch"><a href="clojang.jinterface.erlang.float.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>float</span></div></a></li><li class="depth-4 branch"><a href="clojang.jinterface.erlang.int.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>int</span></div></a></li><li class="depth-4 branch"><a href="clojang.jinterface.erlang.list.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>list</span></div></a></li><li class="depth-4 branch"><a href="clojang.jinterface.erlang.map.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>map</span></div></a></li><li class="depth-4 branch"><a href="clojang.jinterface.erlang.object.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>object</span></div></a></li><li class="depth-4 branch"><a href="clojang.jinterface.erlang.string.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>string</span></div></a></li><li class="depth-4 branch"><a href="clojang.jinterface.erlang.tuple.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>tuple</span></div></a></li><li class="depth-4"><a href="clojang.jinterface.erlang.types.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>types</span></div></a></li><li class="depth-3"><a href="clojang.jinterface.otp.html"><div class="inner"><span class="tree" style="top: -362px;"><span class="top" style="height: 371px;"></span><span class="bottom"></span></span><span>otp</span></div></a></li><li class="depth-4 branch"><a href="clojang.jinterface.otp.connection.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>connection</span></div></a></li><li class="depth-4 branch"><a href="clojang.jinterface.otp.messaging.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>messaging</span></div></a></li><li class="depth-4 branch"><a href="clojang.jinterface.otp.nodes.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>nodes</span></div></a></li><li class="depth-4 branch"><a href="clojang.jinterface.otp.streams.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>streams</span></div></a></li><li class="depth-4"><a href="clojang.jinterface.otp.transport.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>transport</span></div></a></li><li class="depth-2 branch"><a href="clojang.mbox.html"><div class="inner"><span class="tree" style="top: -579px;"><span class="top" style="height: 588px;"></span><span class="bottom"></span></span><span>mbox</span></div></a></li><li class="depth-2 branch"><a href="clojang.msg.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>msg</span></div></a></li><li class="depth-2 branch"><a href="clojang.node.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>node</span></div></a></li><li class="depth-2 branch"><a href="clojang.rpc.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>rpc</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>test</span></div></div></li><li class="depth-3 branch"><a href="clojang.test.core-test.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core-test</span></div></a></li><li class="depth-3"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>jinterface</span></div></div></li><li class="depth-4"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>erlang</span></div></div></li><li class="depth-5"><a href="clojang.test.jinterface.erlang.types-test.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>types-test</span></div></a></li><li class="depth-4"><div class="no-link"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>otp</span></div></div></li><li class="depth-5"><a href="clojang.test.jinterface.otp.nodes-test.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>nodes-test</span></div></a></li><li class="depth-3"><a href="clojang.test.util-test.html"><div class="inner"><span class="tree" style="top: -145px;"><span class="top" style="height: 154px;"></span><span class="bottom"></span></span><span>util-test</span></div></a></li><li class="depth-2 branch"><a href="clojang.types.html"><div class="inner"><span class="tree" style="top: -238px;"><span class="top" style="height: 247px;"></span><span class="bottom"></span></span><span>types</span></div></a></li><li class="depth-2"><a href="clojang.util.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>util</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#talking-to-servers-lfe-clojure" name="talking-to-servers-lfe-clojure"></a>Talking to Servers: LFE &amp; Clojure</h1>
<h2><a href="#clojure-client-with-lfe-server" name="clojure-client-with-lfe-server"></a>Clojure Client with LFE Server</h2>
<h3><a href="#using-otp" name="using-otp"></a>Using OTP</h3>
<p>In the <code>examples</code> directory of the Clojang source code there is a module containing a variation on the classic &ldquo;ping-pong&rdquo; server. It&rsquo;s written in LFE, but it could have been done in any BEAM (Erlang VM) language. Here&rsquo;s the code:</p>
<pre><code class="cl">(defmodule ping-pong
  (behaviour gen_server)
  (export
    ;; gen_server implementation
    (start 0)
    (stop 0)
    ;; callback implementation
    (init 1)
    (handle_call 3)
    (handle_info 2)
    (terminate 2)
    (code_change 3)
    ;; server API
    (ping 0)
    (get-ping-count 0)))

;;; config functions

(defun server-name () (MODULE))
(defun callback-module () (MODULE))
(defun initial-state () 0)
(defun genserver-opts () &#39;())
(defun register-name () `#(local ,(server-name)))
(defun unknown-command () #(error &quot;Unknown command.&quot;))

;;; gen_server implementation

(defun start ()
  (gen_server:start (register-name)
                    (callback-module)
                    (initial-state)
                    (genserver-opts)))

(defun stop ()
  (gen_server:call (server-name) &#39;stop))

;;; callback implementation

(defun init (initial-state)
  `#(ok ,initial-state))

(defun handle_call
  ((&#39;ping _caller state-data)
    `#(reply pong ,(+ 1 state-data)))
  ((&#39;ping-count _caller state-data)
    `#(reply ,state-data ,state-data))
  ((&#39;stop _caller state-data)
    `#(stop shutdown ok ,state-data))
  ((_message _caller state-data)
    `#(reply ,(unknown-command) ,state-data)))

(defun handle_info
  ((`#(EXIT ,_pid normal) state-data)
   `#(noreply ,state-data))
  ((`#(EXIT ,pid ,reason) state-data)
   (io:format &quot;Process ~p exited! (Reason: ~p)~n&quot; `(,pid ,reason))
   `#(noreply ,state-data))
  ((_msg state-data)
   `#(noreply ,state-data)))

(defun terminate (_reason _state-data)
  &#39;ok)

(defun code_change (_old-version state _extra)
  `#(ok ,state))

;;; our server API

(defun ping ()
  (gen_server:call (server-name) &#39;ping))

(defun get-ping-count ()
  (gen_server:call (server-name) &#39;ping-count))
</code></pre>
<p>We&rsquo;re going to compile and then run that code from the LFE REPL. Then, from a Clojure REPL, we&rsquo;ll talk to it.</p>
<p>Start the LFE REPL using the <code>repl</code> make target in the Clojang top-level directory:</p>
<pre><code class="bash">$ make repl
LFE Shell V7.2 (abort with ^G)
(clojang-lfe@mndltl01)&gt;
</code></pre>
<p>Next, compile the example:</p>
<pre><code class="cl">(clojang-lfe@mndltl01)&gt; (c &quot;examples/ping-pong.lfe&quot;)
(#(module ping-pong))
</code></pre>
<p>Now we can start it:</p>
<pre><code class="cl">(clojang-lfe@mndltl01)&gt; (ping-pong:start)
#(ok &lt;0.45.0&gt;)
</code></pre>
<p>In a separate terminal window (in the Clojang top-level directory, just like the <code>make repl</code> command), start up the Clojure REPL:</p>
<pre><code class="bash">$ lein repl
nREPL server started on port 58369 on host 127.0.0.1 - nrepl://127.0.0.1:58369
REPL-y 0.3.7, nREPL 0.2.10
Clojure 1.8.0
clojang.dev=&gt;
</code></pre>
<p>Now we can create nodes for two ends of the connection, and then open a connection between the two:</p>
<pre><code class="clojure">clojang.dev=&gt; (def self (node/self :client))
#&#39;clojang.dev/self
clojang.dev=&gt; (def other (node/peer &quot;clojang-lfe@mndltl01&quot;))
#&#39;clojang.dev/other
clojang.dev=&gt; (def connx (node/connect self other))
#&#39;clojang.dev/connx
</code></pre>
<p>With a connection established, we&rsquo;re able to execute Erlang module/function calls on the remote LFE/Erlang node:</p>
<pre><code class="clojure">clojang.dev=&gt; (conn/!rpc connx :ping-pong :ping)
nil
clojang.dev=&gt; (conn/!rpc connx :ping-pong :ping)
nil
clojang.dev=&gt; (conn/!rpc connx :ping-pong :ping)
nil
clojang.dev=&gt; (conn/receive-rpc connx)
:pong
clojang.dev=&gt; (conn/receive-rpc connx)
:pong
clojang.dev=&gt; (conn/receive-rpc connx)
:pong
clojang.dev=&gt; (conn/!rpc connx :ping-pong :get-ping-count)
nil
clojang.dev=&gt; (conn/receive-rpc connx)
3
</code></pre>
<p>While the emphasis here is remote communications, it goes without saying that local sends are also possible. Since this is a <code>gen_server</code> implementation, the proper way to do this is by calling the API we defined:</p>
<pre><code class="cl">(clojang-lfe@mndltl01)&gt; (ping-pong:ping)
pong
(clojang-lfe@mndltl01)&gt; (ping-pong:ping)
pong
(clojang-lfe@mndltl01)&gt; (ping-pong:ping)
pong
(clojang-lfe@mndltl01)&gt; (ping-pong:get-ping-count)
6
</code></pre>
<h3><a href="#quick-and-dirty" name="quick-and-dirty"></a>Quick and Dirty</h3>
<p>What we&rsquo;ve demonstrated above is the &ldquo;right way&rdquo; to start thinking about long-running processes in the Erlang VM: using the infrastructure of OTP to build for reliability. We could have written something similar, but much more simply. It would also have been very fragile.</p>
<p>For instance, we could have done it like this:</p>
<pre><code class="cl">(clojang-lfe@mndltl01)&gt; (defun png-png (count)
                          (receive
                            (`#(ping ,caller)
                              (! caller &#39;pong) (png-png (+ 1 count)))
                            (`#(get-count ,caller)
                              (! caller count) (png-png count))
                            (`#(stop, caller)
                              (! caller &#39;stopped) &#39;stopped)))
png-png
</code></pre>
<p>Please don&rsquo;t write your LFE OTP apps like this, though :-) You&rsquo;ll slowly end-up reinventing OTP, though a partially-implemented and bug-ridden one.</p>
<p>Back to this demonstration: all we need now to turn this into a simplistic server is to spawn it:</p>
<pre><code class="cl">(clojang-lfe@mndltl01)&gt; (set png-png-pid (spawn (lambda () (png-png 0))))
&lt;0.71.0&gt;
</code></pre>
<p>Let&rsquo;s test it out:</p>
<pre><code class="cl">(clojang-lfe@mndltl01)&gt; (! png-png-pid `#(ping ,(self)))
#(ping &lt;0.68.0&gt;)
(clojang-lfe@mndltl01)&gt; (! png-png-pid `#(ping ,(self)))
#(ping &lt;0.68.0&gt;)
(clojang-lfe@mndltl01)&gt; (! png-png-pid `#(ping ,(self)))
#(ping &lt;0.68.0&gt;)
(clojang-lfe@mndltl01)&gt; (c:flush)
Shell got pong
Shell got pong
Shell got pong
ok
</code></pre>
<p>Since we&rsquo;re using the LFE REPL as the client, we&rsquo;ll need to <code>flush</code> its inbox to get the messages that our simple little server is sending to it.</p>
<p>Let&rsquo;s make the other call:</p>
<pre><code class="cl">(clojang-lfe@mndltl01)&gt; (! png-png-pid `#(get-count ,(self)))
#(get-count &lt;0.68.0&gt;)
(clojang-lfe@mndltl01)&gt; (c:flush)
Shell got 3
ok
</code></pre>
<p>We&rsquo;re going to want to call this from Clojure too, so let&rsquo;s register the LFE process with a name:</p>
<pre><code class="cl">(clojang-lfe@mndltl01)&gt; (register &#39;png-png png-png-pid)
true
</code></pre>
<p>With that done, let&rsquo;s return to the Clojure REPL and make some calls to our second (simple, don&rsquo;t-deploy-with-this) server:</p>
<pre><code class="clojure">clojang.dev=&gt; (conn/! connx :png-png [:ping (node/get-pid self)])
nil
clojang.dev=&gt; (conn/! connx :png-png [:ping (node/get-pid self)])
nil
clojang.dev=&gt; (conn/! connx :png-png [:ping (node/get-pid self)])
nil
clojang.dev=&gt; (conn/receive connx)
:pong
clojang.dev=&gt; (conn/receive connx)
:pong
clojang.dev=&gt; (conn/receive connx)
:pong
clojang.dev=&gt; (conn/! connx :png-png [:get-count (node/get-pid self)])
nil
clojang.dev=&gt; (conn/receive connx)
6
</code></pre>
<p>That looks not-so-erily familiar &hellip;</p>
<h2><a href="#lfe-client-with-clojure-server" name="lfe-client-with-clojure-server"></a>LFE Client with Clojure Server</h2>
<p>In the case of an LFE server, Erlang/OTP defined the service specification (i.e., <code>gen_server</code>), but there is no analog in Clojure (core, anyway; the <a href="http://docs.paralleluniverse.co/pulsar/#behaviors">Pulsar</a> library provides an OTP-inspired <code>gen-server</code>). Sticking with the RPC example, there is no OTP-compliant mechanism for making calls on remote nodes in Clojure. This, of course, is no surprise, since the OTP RPC mechanism is very specific to the Erlang VM.</p>
<p>That being said, it&rsquo;s &ldquo;simply&rdquo; sturctured message passing, and there&rsquo;s no reason we cannot implement our own RPC server &ndash; we just need to be able to hanle RPC messages. The Clojang library offers just this, and in fact, will automatically parse RPC-type messages sent from an Erlang VM node (in our case, LFE, but the mechanism is dialect-agnostic).</p>
<p>To demonstate this we need to set up a long-running Clojure XXX (analog to Erlang VM &ldquo;process&rdquo;, dependent upon implementation) and then make requests to it. The Clojure XXX needs to accept OTP messages, parse them, evaluate the specified code, and then send the results back to the LFE node.</p>
<p>We use the same example as above: a simple ping-pong server which accepts RPC calls. Here is the source code:</p>
<pre><code class="clojure">TBD
</code></pre>
<p>To run the server in the Clojure REPL, slurp it and XXX:</p>
<pre><code class="clojure">TBD
</code></pre>
<p>Now, from your LFE REPL, make some calls:</p>
<pre><code class="cl">TBD
</code></pre>
<p>As with the previous example, it&rsquo;s possible to call the ping-pong server from the same node where the server is running:</p>
<pre><code class="clojure">TBD
</code></pre>
<h3><a href="#quick-and-dirty" name="quick-and-dirty"></a>Quick and Dirty</h3>
<p>With the core.match library for Clojure, we are able to get remarkably close to the little server we wrote in LFE above:</p>
<pre><code class="clojure">(require &#39;[clojure.core.match :refer [match]])

;; XXX Right now this is hanging when executed a second
;;     time; need to debug
(defn png-png
  []
  (let [init-state 0
        self (node/self :srvr)
        _ (node/publish-port self)
        cnnx (node/accept self)]
    (loop [png-count init-state]
      (match [(conn/receive cnnx)]
        [[:ping caller]] (do (conn/! cnnx caller :pong)
                             (recur (inc png-count)))
        [[:get-count caller]] (do (conn/! cnnx caller png-count)
                                  (recur png-count))
        [[:stop caller]] (do (conn/unlink cnnx caller)
                             (node/unpublish self)
                             :stopped)))))
</code></pre>
<p>Let&rsquo;s paste this server into the Clojure REPL and then run it:</p>
<pre><code class="clojure">(png-png)
</code></pre>
<p>Now let&rsquo;s head over to an LFE REPL and talk to the Clojure server:</p>
<pre><code class="cl">(clojang-lfe@mndltl01)&gt; (! #(srvr srvr@mndltl01) `#(ping ,(self)))
#(ping &lt;0.34.0&gt;)
(clojang-lfe@mndltl01)&gt; (! #(srvr srvr@mndltl01) `#(ping ,(self)))
#(ping &lt;0.34.0&gt;)
(clojang-lfe@mndltl01)&gt; (! #(srvr srvr@mndltl01) `#(ping ,(self)))
#(ping &lt;0.34.0&gt;)
(clojang-lfe@mndltl01)&gt; (c:flush)
Shell got pong
Shell got pong
Shell got pong
ok
(clojang-lfe@mndltl01)&gt; (! #(srvr srvr@mndltl01) `#(get-count ,(self)))
#(get-count &lt;0.34.0&gt;)
(clojang-lfe@mndltl01)&gt; (c:flush)
Shell got 3
ok
</code></pre>
<p>Once we&rsquo;re done, we can ask the server to stop from LFE:</p>
<pre><code class="cl">(clojang-lfe@mndltl01)&gt; (! #(srvr srvr@mndltl01) `#(stop ,(self)))
#(stop &lt;0.34.0&gt;)
</code></pre>
<p>Back in the Clojure REPL you should now see:</p>
<pre><code class="clojure">:stopped
</code></pre></div></div></div></body></html>